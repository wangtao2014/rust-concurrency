# Thread

- 进程和线程
    - 很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 1:1，一个 OS 线程对应一个语言线程。
    - Rust 标准库只提供了 1:1 线程实现；有一些 crate 实现了其他有着不同取舍的线程模型。

- thread::spawn
- move 
- JoinHandler

# 并发方式
- 消息传递 和 共享状态（两种方式）

- 消息传递 ： 不要通过共享内存来通讯；而是通过通讯来共享内存
    - 信道 channel 编程中的信息渠道（信道）有两部分组成，一个 发送者（transmitter） 和一个 接收者（receiver）。代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到的消息。当发送者或接收者任一被丢弃时可以认为信道被 关闭（closed）

- 信道与所有权转移
    - send 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。

- 发送多个值并观察接收者的等待
    - mpsc 是 multiple producer, single consumer 的缩写
    - 可以运用 mpsc 扩展代码来创建向同一接收者发送值的多个线程

- 共享状态
    - 信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值
    - 共享内存类似于多所有权：多个线程可以同时访问相同的内存位置
    - 智能指针使得多所有权成为可能

- 互斥器一次只允许一个线程访问数据 mutex mutual exclusion
    - 描述互斥器为通过锁系统 保护（guarding） 其数据
    - 互斥器以难以使用著称，因为你不得不记住：
        - 在使用数据之前尝试获取锁。
        - 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。
    - 一旦获取了锁，就可以将返回值（在这里是 num）视为一个其内部数据的可变引用了

- 在线程间共享 Mutex<T>
    - send trait: 这是确保所使用的类型可以用于并发环境的 trait 之一
    - Rc<T> 单线程
    - Arc<T> 多线程 线程安全的方式改变引用计数的类型

# send and sync
- send trait
    - Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送
    - 几乎所有的 Rust 类型都是 Send 的,Rc<T> 例外
    - 因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数

- Sync trait
    - Sync 标记 trait 表明一个实现了 Sync 的类型可以安全的在多个线程中拥有其值的引用

- 手动实现 Send 和 Sync 是不安全的

-[无畏并发](https://github.com/endruz/kulolo/tree/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/1-Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/16.%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91)
